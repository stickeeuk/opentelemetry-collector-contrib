# Interval Processor

<!-- status autogenerated section -->
| Status        |           |
| ------------- |-----------|
| Stability     | [development]: metrics   |
| Distributions | [] |
| Warnings      | [Statefulness](#warnings) |
| Issues        | [![Open issues](https://img.shields.io/github/issues-search/open-telemetry/opentelemetry-collector-contrib?query=is%3Aissue%20is%3Aopen%20label%3Aprocessor%aggregation%20&label=open&color=orange&logo=opentelemetry)](https://github.com/open-telemetry/opentelemetry-collector-contrib/issues?q=is%3Aopen+is%3Aissue+label%3Aprocessor%aggregation) [![Closed issues](https://img.shields.io/github/issues-search/open-telemetry/opentelemetry-collector-contrib?query=is%3Aissue%20is%3Aclosed%20label%3Aprocessor%aggregation%20&label=closed&color=blue&logo=opentelemetry)](https://github.com/open-telemetry/opentelemetry-collector-contrib/issues?q=is%3Aclosed+is%3Aissue+label%3Aprocessor%aggregation) |
| [Code Owners](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/CONTRIBUTING.md#becoming-a-code-owner)    | [@RichieSams](https://www.github.com/RichieSams), [@sh0rez](https://www.github.com/sh0rez), [@djaglowski](https://www.github.com/djaglowski) |

[development]: https://github.com/open-telemetry/opentelemetry-collector/blob/main/docs/component-stability.md#development
<!-- end autogenerated section -->

## Description

The aggregation processor (`aggregationprocessor`) aggregates metrics and periodically forwards the latest values to the next component in the pipeline. The processor supports aggregating the following metric types:

* Delta sums
* Delta histograms
* ~Delta exponential histograms~ Not yet supported

The following metric types will *not* be aggregated, and will instead be passed, unchanged, to the next component in the pipeline:

* All cumulative metrics
* Gauges
* Summaries

> NOTE: Aggregating data over an interval is an inherently "lossy" process. For monotonically increasing, cumulative sums, histograms, and exponential histograms, you "lose" precision, but you don't lose overall data. But for non-monotonically increasing sums, gauges, and summaries, aggregation represents actual data loss. IE you could "lose" that a value increased and then decreased back to the original value. In most cases, this data "loss" is ok.

## Configuration

The following settings can be optionally configured:

```yaml
aggregationprocessor:
  # The interval in which the processor should export the aggregated metrics.
  [ interval: <duration> | default = 15s ]
```

## Example of metric flows

The following sum metrics come into the processor to be handled

| Timestamp | Metric Name  | Aggregation Temporarility | Attributes        | Value |
| --------- | ------------ | ------------------------- | ----------------- | ----: |
| 0         | test_metric  | Delta                     | labelA: foo       |   4.0 |
| 2         | test_metric  | Delta                     | labelA: bar       |  -3.1 |
| 4         | other_metric | Cumulative                | fruitType: orange |  77.4 |
| 6         | test_metric  | Delta                     | labelA: foo       |   8.2 |
| 8         | test_metric  | Delta                     | labelA: foo       |  12.8 |
| 10        | test_metric  | Delta                     | labelA: bar       |   6.4 |

The processor would immediately pass the following metrics to the next processor in the chain

| Timestamp | Metric Name  | Aggregation Temporarility | Attributes        | Value |
| --------- | ------------ | ------------------------- | ----------------- | ----: |
| 4         | other_metric | Cumulative                | fruitType: orange |  77.4 |

Because it's a Cumulative metric.

At the next `interval` (15s by default), the processor would pass the following metrics to the next processor in the chain

| Timestamp | Metric Name | Aggregation Temporarility | Attributes  | Value |
| --------- | ----------- | ------------------------- | ----------- | ----: |
| 0         | test_metric | Delta                     | labelA: foo |    25 |
| 2         | test_metric | Delta                     | labelA: bar |   3.3 |

> [!IMPORTANT]
> After exporting, any internal state is cleared. So if no new metrics come in, the next interval will export nothing.
